---
title: 分區 vs 分表
parent: DB
---

# 分區 vs 分表

## **🔹 分區（Partitioning） vs. 分表（Sharding）**

在 **MySQL** 或 **資料庫設計** 中，**分區（Partitioning）** 和 **分表（Sharding）** 都是為了 **優化數據存儲和查詢性能** 的手段，但它們有 **本質區別**。

---

# **1️⃣ 什麼是分區（Partitioning）**

**分區** 是 **MySQL 內部** 提供的一種 **儲存最佳化技術**，**表的邏輯結構仍然是一個**，但資料在 **實體儲存層面** 被分割成 **多個分區**。

✅ **特點：**

- **邏輯上仍然是一個表**，寫 SQL 查詢時 **不用手動指定分區**，MySQL 會自動選擇分區查詢。
- **底層資料儲存在多個分區**，每個分區可以存不同的資料範圍。
- **減少全表掃描，提高查詢效率**。
- **不能跨分區的鍵進行 JOIN**，否則查詢效能會變差。

🚀 **分區表的建立方式：**

```sql
CREATE TABLE orders (
 id INT NOT NULL,
 order_date DATE NOT NULL,
 customer_id INT NOT NULL,
 amount DECIMAL(10,2) NOT NULL,
 PRIMARY KEY (id, order_date)
)
PARTITION BY RANGE(YEAR(order_date)) (
 PARTITION p0 VALUES LESS THAN (2022),
 PARTITION p1 VALUES LESS THAN (2023),
 PARTITION p2 VALUES LESS THAN (2024)
);

```

📌 **解讀**：

- 這張 `orders` 表 **按年份分區**：
 - **p0** 存 `2021 年之前的訂單`。 
- **p1** 存 `2022 年的訂單`。 
- **p2** 存 `2023 年的訂單`。

🔥 **查詢時，MySQL 會自動選擇適當的分區**

```sql
SELECT * FROM orders WHERE order_date >= '2022-01-01';
```

🔍 **優勢：**

1. **查詢更快**：MySQL 只掃描 **符合的分區**，避免全表掃描。

2. **資料管理更方便**：可以快速 **刪除整個分區**，而不影響其他資料。

⚠️ **限制：**

1. ❌ **無法動態增加分區**（每次要手動修改分區）。

2. ❌ **分區鍵必須是主鍵的一部份**。

3. ❌ **不支援外鍵**，如果有外鍵就不能用分區。


# **2️⃣ 什麼是分表（Sharding）**

**分表** 是 **手動** 將 **一張大表拆成多個小表**，通常用於 **海量資料最佳化**，由 **應用程式或中間件（如 ShardingSphere）** 負責路由到正確的表。

✅ **特點：**

- **不是 MySQL 原生功能，需要自行控制**。
- **多個小表獨立存在**，需要程式碼層級**自己決定查詢哪個表**。
- **通常會依照某個規則（例如 ID 取模、時間範圍等）來劃分**。
- **可以是同一個資料庫內的多個表格**，也可以是**多個資料庫**（分庫分表）。

🚀 **手動分表的範例**

假設我們要存儲

**使用者資料**，原來的 `users` 表 **太大**，查詢變慢，我們可以 **按 user_id 取模分表**：

```sql
CREATE TABLE users_0 LIKE users;
CREATE TABLE users_1 LIKE users;
CREATE TABLE users_2 LIKE users;
```

📌 **應用程式碼中動態決定要儲存在哪個表**

```typescript
const userId = 12345;
const tableName = `users_${userId % 3}`; // 取模分表
const sql = `SELECT * FROM ${tableName} WHERE id = ${userId}`;
```

🔥 **查詢** **`userId=12345`** **的資料時，自動存取** **`users_0`**。

🔍 **優勢：**

1. ✅ **水平擴充**：單表不超過 **數百萬**，查詢更快。

2. ✅ **更適合分散式系統**：可以跨多個數據庫，減少單庫壓力。

3. ✅ **更靈活**：分表規則可定制，例如按 `user_id` 取模，或按 `時間` 進行分表。

⚠️ **限制：**

1. ❌ **查詢麻煩**：如果 `user_id` 沒有規則，查詢所有使用者會很慢，需要遍歷所有資料表。

2. ❌ **事務處理困難**：跨表操作不方便，需要應用層處理。

3. ❌ **索引不能跨表使用**，無法直接 `JOIN`，要在應用層合併資料。


# **3️⃣ 分區 vs. 分表（對比）🔍**

| 維度 | **分區（Partitioning）** | **分表（Sharding）** |
| --- | --- | --- |
| **作用** | 最佳化存儲，減少全表掃描 | 解決單表資料過大問題 |
| **實作方式** | MySQL **原生支援** | 需要 **手動實作** |
| **資料儲存** | **邏輯上仍是一個表格**，實體上分區儲存 | **多個獨立的表格**，應用層決定儲存在哪裡 |
| **查詢** | **MySQL 自動最佳化**，寫 SQL 時不變 | 需要 **程式碼層面路由** 查詢哪個表 |
| **索引** | **跨分區索引可用** | **分表後索引不共用** |
| **事務** | **事務完整性保留** | **跨表事務複雜**，需額外處理 |
| **適用場景** | **單機最佳化，適用於 OLAP**（查詢最佳化） | **分散式資料庫，適用於 OLTP**（高並發場景） |

---

# **4️⃣ 什麼時候用分區，什麼時候用分表？ **

✅ **用分區（Partitioning）**：

- **資料量大，但查詢頻率高**（如 **訂單、日誌、歷史資料**）。
- 主要用於 **MySQL 內部最佳化**，減少 **全表掃描**。

✅ **用分表（Sharding）**：

- **單表資料過大（超過 500 萬~千萬級）**，查詢變慢。
- **高並發寫入，資料庫壓力大**。
- **需要水平擴展到多個資料庫**（分庫分表）。
- **要減少單表索引大小，提高查詢效率**。

---

# **5️⃣ 總結**

**🚀 分區（Partitioning）：**

- **MySQL 內建功能**，邏輯上仍是 **同一張表**，物理上分多個分區。
- **適合大量資料**（如 **日誌、訂單資料**），MySQL **自動最佳化查詢**。
- **不能動態擴充分區**，管理成本較高。

**🔥 分表（Sharding）：**

- **手動分表**，或透過 **ShardingSphere、Vitess、MyCat 等中間件** 進行自動分片。
- **適合高並發寫入和水平擴展**，可跨多個資料庫。
- **查詢時要自己決定要存取哪個表**，事務處理複雜。

---

# **📌 結論**

- **如果是 MySQL 單庫最佳化（不拆程式庫）** → **用分區** 🚀
- **如果是資料量特別大、需要跨資料庫擴充** → **用分表** 🔥
- **如果只是單表最佳化查詢，不想改表結構** → **可以考慮索引最佳化、歸檔資料等方式**。

---

🔹 依照目前需求？

如果只是 **增加欄位、最佳化查詢**，可以考慮 **索引最佳化**，不一定要 **分表**。

如果 **單表超大（千萬等級以​​上）**，那可以考慮 **分表** 方案 🚀